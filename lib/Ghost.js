// Generated by CoffeeScript 1.9.1
(function() {
  var Ghost, Nar, ServerWorker, Worker,
    slice = [].slice;

  Nar = this.Nar || this.Ikagaka.Nar || require("ikagaka.nar.js");

  Worker = this.Worker;

  ServerWorker = (function() {
    function ServerWorker(fn, args, imports) {
      if (imports == null) {
        imports = [];
      }
      this.url = URL.createObjectURL(new Blob([
        imports.map(function(src) {
          return "importScripts('" + src + "');\n";
        }).join("") + "\n", "(" + ServerWorker.Server + ")();\n", "var createTransferable = " + ServerWorker.createTransferable + ";\n", "(" + fn + ")(" + (args.map(JSON.stringify).join(",")) + ");"
      ], {
        type: "text/javascript"
      }));
      this.worker = new Worker(this.url);
      this.worker.addEventListener("error", function(ev) {
        var ref;
        return console.error(((ref = ev.error) != null ? ref.stack : void 0) || ev.error || ev);
      });
      this.worker.addEventListener("message", (function(_this) {
        return function(arg) {
          var args, id, ref, ref1;
          ref = arg.data, id = ref[0], args = ref[1];
          (ref1 = _this.callbacks)[id].apply(ref1, args);
          return delete _this.callbacks[id];
        };
      })(this));
      this.requestId = 0;
      this.callbacks = {};
    }

    ServerWorker.prototype.request = function() {
      var arg, callback, data, event, i, id, transferable;
      event = arguments[0], arg = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), callback = arguments[i++];
      data = arg[0], transferable = arg[1];
      id = this.requestId++;
      this.callbacks[id] = callback;
      return this.worker.postMessage([id, event, data], transferable);
    };

    ServerWorker.prototype.terminate = function() {
      this.worker.terminate();
      return URL.revokeObjectURL(this.url);
    };

    ServerWorker.Server = function() {
      return (function() {
        var handlers;
        handlers = {};
        self.addEventListener("message", function(arg) {
          var data, event, id, ref, reply;
          ref = arg.data, id = ref[0], event = ref[1], data = ref[2];
          reply = function(args, transferable) {
            return self.postMessage([id, args], transferable);
          };
          handlers[event](data, reply);
        });
        return self.on = function(event, callback) {
          handlers[event] = callback;
        };
      })();
    };

    ServerWorker.createTransferable = function(dic) {
      var hits, keys;
      keys = Object.keys(dic);
      hits = keys.filter(function(filepath) {
        return !!filepath;
      });
      return hits.reduce((function(arg, key) {
        var _dic, buffer, buffers;
        _dic = arg[0], buffers = arg[1];
        buffer = dic[key];
        _dic[key] = buffer;
        buffers.push(buffer);
        return [_dic, buffers];
      }), [{}, []]);
    };

    return ServerWorker;

  })();

  Ghost = (function() {
    function Ghost(dirpath1, directory, path) {
      var args, buffer, descriptTxt, fn, imports, ref, shiori;
      this.dirpath = dirpath1;
      if (path == null) {
        path = '';
      }
      if (!directory["descript.txt"]) {
        throw new Error("descript.txt not found");
      }
      this.directory = directory;
      buffer = this.directory["descript.txt"];
      descriptTxt = Nar.convert(buffer);
      this.descript = Nar.parseDescript(descriptTxt);
      shiori = Object.keys(Ghost.shiories).find((function(_this) {
        return function(shiori) {
          return Ghost.shiories[shiori].detect(_this.directory);
        };
      })(this));
      if (!shiori) {
        throw new Error("shiori not found or unknown shiori");
      }
      if (Ghost.shiories[shiori].worker == null) {
        throw new Error("unsupport shiori");
      }
      ref = Ghost.shiories[shiori].worker, fn = ref[0], args = ref[1];
      imports = (Ghost.shiories[shiori].imports || []).map((function(_this) {
        return function(src) {
          return _this.path + path + src;
        };
      })(this));
      this.server = new ServerWorker(fn, args, imports);
    }

    Ghost.prototype.push = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var buffers, directory, ref;
          ref = ServerWorker.createTransferable(_this.directory), directory = ref[0], buffers = ref[1];
          _this.server.request("push", [_this.dirpath, directory], buffers, function(err) {
            if (err != null) {
              return reject(err);
            } else {
              return resolve();
            }
          });
          return _this.directory = null;
        };
      })(this));
    };

    Ghost.prototype.load = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.server.request("load", _this.dirpath, function(err, code) {
            if (err != null) {
              return reject(err);
            } else {
              return resolve(code);
            }
          });
        };
      })(this));
    };

    Ghost.prototype.request = function(request) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this.logging) {
            console.log(request);
          }
          return _this.server.request("request", request, function(err, response) {
            if (err != null) {
              return reject(err);
            } else {
              if (_this.logging) {
                console.log(response);
              }
              return resolve(response);
            }
          });
        };
      })(this));
    };

    Ghost.prototype.unload = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.server.request("unload", function(err, code) {
            if (err != null) {
              return reject(err);
            } else {
              return resolve(code);
            }
          });
        };
      })(this));
    };

    Ghost.prototype.pull = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.server.request("pull", _this.dirpath, function(err, dirs) {
            if (err != null) {
              return reject(err);
            } else {
              return resolve(dirs);
            }
          });
        };
      })(this));
    };

    Ghost.prototype.path = location.protocol + "//" + location.host + location.pathname.split("/").reverse().slice(1).reverse().join("/") + "/";

    Ghost.prototype.logging = false;

    Ghost.nativeShioriWorkerScript = function(CONSTRUCTOR_NAME) {
      var prepareSatori, shiori, shiorihandler;
      shiori = new self[CONSTRUCTOR_NAME]();
      shiori.Module.logReadFiles = true;
      shiorihandler = new NativeShiori(shiori, true);
      self.on("push", function(arg, reply) {
        var dirpath, dirs, error;
        dirpath = arg[0], dirs = arg[1];
        if (CONSTRUCTOR_NAME === "Satori") {
          dirs = prepareSatori(dirs);
        }
        try {
          shiorihandler.push(dirpath, dirs);
        } catch (_error) {
          error = _error;
        }
        return reply([error != null ? error.stack : void 0]);
      });
      self.on("load", function(dirpath, reply) {
        var code, error;
        try {
          code = shiorihandler.load(dirpath);
        } catch (_error) {
          error = _error;
        }
        return reply([error != null ? error.stack : void 0, code]);
      });
      self.on("request", function(request, reply) {
        var error, response;
        try {
          response = shiorihandler.request(request);
        } catch (_error) {
          error = _error;
        }
        return reply([error != null ? error.stack : void 0, response]);
      });
      self.on("unload", function(_, reply) {
        var code, error;
        try {
          code = shiorihandler.unload();
        } catch (_error) {
          error = _error;
        }
        return reply([error != null ? error.stack : void 0, code]);
      });
      self.on("pull", function(dirpath, reply) {
        var buffers, directory, dirs, error, ref;
        try {
          directory = shiorihandler.pull(dirpath);
          ref = createTransferable(directory), dirs = ref[0], buffers = ref[1];
        } catch (_error) {
          error = _error;
        }
        return reply([error != null ? error.stack : void 0, dirs], buffers);
      });
      return prepareSatori = function(data) {
        var filepath, filestr, uint8arr;
        for (filepath in data) {
          if (/\bsatori_conf\.txt$/.test(filepath)) {
            uint8arr = new Uint8Array(data[filepath]);
            filestr = Encoding.codeToString(Encoding.convert(uint8arr, 'UNICODE', 'SJIS'));
            if (/＠SAORI/.test(filestr)) {
              filestr = filestr.replace(/＠SAORI/, '＠NO__SAORI');
              data[filepath] = new Uint8Array(Encoding.convert(Encoding.stringToCode(filestr), 'SJIS', 'UNICODE'));
            }
            break;
          }
        }
        return data;
      };
    };

    Ghost.shiories = {
      kawari: {
        detect: function(dir) {
          return !!dir["kawarirc.kis"];
        },
        imports: ["encoding.min.js", "nativeshiori.js", "kawari.js"],
        worker: [Ghost.nativeShioriWorkerScript, ["Kawari"]]
      },
      kawari7: {
        detect: function(dir) {
          return !!dir["kawari.ini"];
        },
        imports: ["encoding.min.js", "nativeshiori.js", "kawari7.js"],
        worker: [Ghost.nativeShioriWorkerScript, ["Kawari7"]]
      },
      satori: {
        detect: function(dir) {
          return !!dir["satori.dll"];
        },
        imports: ["encoding.min.js", "nativeshiori.js", "libsatori.js"],
        worker: [Ghost.nativeShioriWorkerScript, ["Satori"]]
      },
      yaya: {
        detect: function(dir) {
          return !!dir["yaya.dll"];
        },
        imports: ["encoding.min.js", "nativeshiori.js", "yaya.js"],
        worker: [Ghost.nativeShioriWorkerScript, ["YAYA"]]
      },
      aya5: {
        detect: function(dir) {
          return !!dir["aya5.dll"];
        },
        imports: ["encoding.min.js", "nativeshiori.js", "aya5.js"],
        worker: [Ghost.nativeShioriWorkerScript, ["AYA5"]]
      },
      aya: {
        detect: function(dir) {
          return !!dir["aya.dll"];
        }
      },
      miyojs: {
        detect: function(dir) {
          return !!dir["node.exe"];
        }
      },
      misaka: {
        detect: function(dir) {
          return !!dir["misaka.dll"];
        }
      }
    };

    Ghost.ServerWorker = ServerWorker;

    return Ghost;

  })();

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Ghost;
  } else if (this.Ikagaka != null) {
    this.Ikagaka.Ghost = Ghost;
  } else {
    this.Ghost = Ghost;
  }

}).call(this);
