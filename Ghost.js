// Generated by CoffeeScript 1.8.0
(function() {
  var Ghost, Nar, Worker;

  Nar = this.Nar || this.Ikagaka.Nar || require("ikagaka.nar.js");

  Worker = this.Worker;

  Ghost = (function() {
    function Ghost(directory) {
      var buffer, descriptTxt;
      if (!directory["descript.txt"]) {
        throw new Error("descript.txt not found");
      }
      this.directory = directory;
      buffer = this.directory["descript.txt"].asArrayBuffer();
      descriptTxt = Nar.convert(buffer);
      this.descript = Nar.parseDescript(descriptTxt);
      this.worker = null;
    }

    Ghost.prototype.load = function(callback) {
      var args, buffers, directory, fn, imports, keys, shiori, _ref, _ref1;
      if (!this.directory[this.descript["shiori"]] && !this.directory["shiori.dll"]) {
        setTimeout(function() {
          return callback(new Error("shiori not found"));
        });
        return;
      }
      keys = Object.keys(Ghost.shiories);
      shiori = keys.find((function(_this) {
        return function(shiori) {
          return Ghost.shiories[shiori].detect(_this.directory);
        };
      })(this));
      if (!shiori) {
        setTimeout(function() {
          return callback(new Error("unkown shiori"));
        });
        return;
      }
      if (typeof (Ghost.shiories[shiori].worker != null) === "undefined") {
        setTimeout(function() {
          return callback(new Error("unsupport shiori"));
        });
        return;
      }
      _ref = Ghost.shiories[shiori].worker, fn = _ref[0], args = _ref[1];
      imports = (Ghost.shiories[shiori].imports || []).map((function(_this) {
        return function(src) {
          return _this.path + src;
        };
      })(this));
      this.worker = Ghost.createWorker(fn, args, imports);
      _ref1 = Ghost.createTransferable(this.directory), directory = _ref1.directory, buffers = _ref1.buffers;
      this.worker.addEventListener("error", function(ev) {
        var _ref2;
        return console.error(((_ref2 = ev.error) != null ? _ref2.stack : void 0) || ev.error || ev);
      });
      this.worker.postMessage({
        event: "load",
        data: directory
      }, buffers);
      delete this.directory;
      this.worker.onmessage = function(_arg) {
        var error, event, _ref2;
        _ref2 = _arg.data, event = _ref2.event, error = _ref2.error;
        if (event === "loaded") {
          return callback(error);
        }
      };
    };

    Ghost.prototype.request = function(request, callback) {
      if (this.logging) {
        console.log(request);
      }
      this.worker.postMessage({
        event: "request",
        data: request
      });
      this.worker.onmessage = (function(_this) {
        return function(_arg) {
          var error, event, response, _ref;
          _ref = _arg.data, event = _ref.event, error = _ref.error, response = _ref.data;
          if (_this.logging) {
            console.log(response);
          }
          if (event === "response") {
            return callback(error, response);
          }
        };
      })(this);
    };

    Ghost.prototype.unload = function(callback) {
      this.worker.postMessage({
        event: "unload"
      });
      this.worker.onmessage = function(_arg) {
        var error, event, _ref;
        _ref = _arg.data, event = _ref.event, error = _ref.error;
        if (event === "unloaded") {
          return callback(error);
        }
      };
    };

    Ghost.prototype.path = location.protocol + "//" + location.host + location.pathname.split("/").reverse().slice(1).reverse().join("/") + "/";

    Ghost.prototype.logging = false;

    Ghost.nativeShioriWorkerScript = function(CONSTRUCTOR_NAME) {
      var prepareSatori, shiori, shiorihandler;
      shiori = new self[CONSTRUCTOR_NAME]();
      shiori.Module.logReadFiles = true;
      shiorihandler = null;
      self.onmessage = function(_arg) {
        var code, data, directorys, error, event, request, response, _ref;
        _ref = _arg.data, event = _ref.event, data = _ref.data;
        error = null;
        switch (event) {
          case "load":
            if (CONSTRUCTOR_NAME === "Satori") {
              data = prepareSatori(data);
            }
            directorys = data;
            shiorihandler = new NativeShiori(shiori, directorys, true);
            try {
              code = shiorihandler.load('/home/web_user/');
            } catch (_error) {
              error = _error;
            }
            return self.postMessage({
              event: "loaded",
              error: error,
              data: code
            });
          case "request":
            request = data;
            try {
              response = shiorihandler.request(request);
            } catch (_error) {
              error = _error;
            }
            return self.postMessage({
              event: "response",
              error: error,
              data: response
            });
          case "unload":
            try {
              code = shiorihandler.unload();
            } catch (_error) {
              error = _error;
            }
            return self.postMessage({
              event: "unloaded",
              error: error,
              data: code
            });
          default:
            throw new Error(event + " event not support");
        }
      };
      return prepareSatori = function(data) {
        var filepath, filestr, uint8arr;
        for (filepath in data) {
          if (/\bsatori_conf\.txt$/.test(filepath)) {
            uint8arr = new Uint8Array(data[filepath]);
            filestr = Encoding.codeToString(Encoding.convert(uint8arr, 'UNICODE', 'SJIS'));
            if (/＠SAORI/.test(filestr)) {
              filestr = filestr.replace(/＠SAORI/, '＠NO__SAORI');
              data[filepath] = new Uint8Array(Encoding.convert(Encoding.stringToCode(filestr), 'SJIS', 'UNICODE'));
            }
            break;
          }
        }
        return data;
      };
    };

    Ghost.shiories = {
      kawari: {
        detect: function(dir) {
          return !!dir["kawarirc.kis"];
        },
        imports: ["encoding.min.js", "nativeshiori.js", "kawari.js"],
        worker: [Ghost.nativeShioriWorkerScript, ["Kawari"]]
      },
      kawari7: {
        detect: function(dir) {
          return !!dir["kawari.ini"];
        },
        imports: ["encoding.min.js", "nativeshiori.js", "kawari7.js"],
        worker: [Ghost.nativeShioriWorkerScript, ["Kawari7Shiori"]]
      },
      satori: {
        detect: function(dir) {
          return !!dir["satori.dll"];
        },
        imports: ["encoding.min.js", "nativeshiori.js", "libsatori.js"],
        worker: [Ghost.nativeShioriWorkerScript, ["Satori"]]
      },
      yaya: {
        detect: function(dir) {
          return !!dir["yaya.dll"];
        },
        imports: ["encoding.min.js", "nativeshiori.js", "yaya.js"],
        worker: [Ghost.nativeShioriWorkerScript, ["YAYA"]]
      },
      aya5: {
        detect: function(dir) {
          return !!dir["aya5.dll"];
        },
        imports: ["encoding.min.js", "nativeshiori.js", "aya5.js"],
        worker: [Ghost.nativeShioriWorkerScript, ["AYA5"]]
      },
      aya: {
        detect: function(dir) {
          return !!dir["aya.dll"];
        }
      },
      miyojs: {
        detect: function(dir) {
          return !!dir["node.exe"];
        }
      },
      misaka: {
        detect: function(dir) {
          return !!dir["misaka.dll"];
        }
      }
    };

    Ghost.createWorker = function(fn, args, imports) {
      if (imports == null) {
        imports = [];
      }
      return new Worker(URL.createObjectURL(new Blob([
        imports.map(function(src) {
          return "importScripts('" + src + "');\n";
        }).join(""), "(" + fn + ")(" + (args.map(JSON.stringify).join(",")) + ");"
      ], {
        type: "text/javascript"
      })));
    };

    Ghost.createTransferable = function(_directory) {
      return Object.keys(_directory).filter(function(filepath) {
        return !!filepath;
      }).reduce((function(_arg, filepath) {
        var buffer, buffers, directory;
        directory = _arg.directory, buffers = _arg.buffers;
        buffer = _directory[filepath].asArrayBuffer();
        directory[filepath] = buffer;
        buffers.push(buffer);
        return {
          directory: directory,
          buffers: buffers
        };
      }), {
        directory: {},
        buffers: []
      });
    };

    return Ghost;

  })();

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Ghost;
  } else if (this.Ikagaka != null) {
    this.Ikagaka.Ghost = Ghost;
  } else {
    this.Ghost = Ghost;
  }

}).call(this);
