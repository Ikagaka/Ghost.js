// Generated by CoffeeScript 1.8.0
var MiyoShioriWorker, Nar, fsb;

self.importScripts("encoding.min.js");

self.importScripts("shiorijk.js");

self.importScripts("browserfs.js");

self.importScripts("ikagaka.nar.js");

self.importScripts("simple-ini.js");

Nar = this.Nar || this.Ikagaka.Nar;

BrowserFS.install(this);

fsb = new BrowserFS.FileSystem.InMemory();

BrowserFS.initialize(fsb);

MiyoShioriWorker = (function() {
  function MiyoShioriWorker(storage) {
    this.storage = storage;
  }

  MiyoShioriWorker.prototype.load = function(dirpath) {
    var Miyo, cmd, dir, ini, shiori, sini;
    if (this.storage != null) {
      this._load_fs(dirpath);
    }
    shiori = (Nar.parseDescript(Nar.convert(this.storage["descript.txt"]))).shiori;
    ini = shiori['SHIOLINK.INI'] || shiori['SHIOLINK.ini'] || shiori['shiolink.ini'] || shiori['shiolink.INI'];
    if (!ini) {
      throw 'only SHIOLINK.INI support is available';
    }
    sini = new SimpleIni(function() {
      return Encoding.codeToString(Encoding.convert(ini, 'UNICODE', 'AUTO'));
    });
    if (!sini.hasSection('SHIOLINK')) {
      throw 'SHIOLINK.INI has no SHIOLINK section';
    }
    cmd = sini.get('SHIOLINK.commandline');
    dir = (cmd.split(/\s*/))[2] || '.';
    Miyo = require('miyojs');
    this.shiori = new Miyo(Miyo.DictionaryLoader.load_recursive(dir));
    return this.shiori.load(dirpath);
  };

  MiyoShioriWorker.prototype._load_fs = function(base_directory) {
    var content, dir, dirname, file, filepath, fs, path, _i, _len, _ref, _results;
    fs = require('fs');
    path = require('path');
    _ref = this.storage;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      filepath = _ref[_i];
      dirname = path.dirname(filepath);
      dir = path.join(base_directory, dirname);
      try {
        fs.statSync(dir);
      } catch (_error) {
        this._mkpath(dir);
      }
      if (!/\/$/.test(filepath)) {
        content = new Uint8Array(this.storage[filepath]);
        file = path.join(base_directory, filepath);
        _results.push(fs.writeFileSync(file, content, {
          encoding: 'binary'
        }));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  MiyoShioriWorker.prototype._mkpath = function(dir) {
    var fs, mkdir, path;
    fs = require('fs');
    path = require('path');
    mkdir = function(dir) {
      try {
        return fs.statSync(dir);
      } catch (_error) {
        mkdir(payh.dirname(dir));
        return fs.mkdirSync(dir);
      }
    };
    mkdir(dir);
    return true;
  };

  return MiyoShioriWorker;

})();

self.onmessage = function(_arg) {
  var data, dictionary, directory, event, parser, request, requestTxt, shiori, _ref;
  _ref = _arg.data, event = _ref.event, data = _ref.data;
  switch (event) {
    case "load":
      directory = data;
      dictionary = Object.keys(directory).filter(function(filepath) {
        return /^dictionaries\/[^/]+$/.test(filepath);
      }).reduce((function(dictionary, filepath) {
        var dic, tabIndentedYaml, uint8Arr, yaml;
        uint8Arr = new Uint8Array(directory[filepath]);
        tabIndentedYaml = Encoding.codeToString(Encoding.convert(uint8Arr, 'UNICODE', 'AUTO'));
        yaml = tabIndentedYaml.replace(/\t/g, ' ');
        dic = jsyaml.safeLoad(yaml);
        Miyo.DictionaryLoader.merge_dictionary(dic, dictionary);
        return dictionary;
      }), {});
      shiori = new Miyo(dictionary);
      console.log(Object.keys(dictionary).join(' '));
      return shiori.load('').then(function() {
        return self.postMessage({
          "event": "loaded",
          "error": null
        });
      })["catch"](function(error) {
        return console.warn(error);
      });
    case "request":
      requestTxt = data;
      parser = new ShioriJK.Shiori.Request.Parser();
      request = parser.parse(requestTxt);
      return shiori.request(request).then(function(response) {
        return self.postMessage({
          event: "response",
          error: null,
          data: '' + response
        });
      })["catch"](function(error) {
        return console.warn(error);
      });
    case "unload":
      return shiori.unload().then(function() {
        return self.postMessage({
          event: "unloaded",
          error: null
        });
      })["catch"](function(error) {
        return console.warn(error);
      });
    default:
      throw new Error(event + " event not support");
  }
};
